<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Draw on Image</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      text-align: center;
    }

    canvas {
      border: 1px solid #ccc;
      cursor: crosshair;
      max-width: 100%;
    }

    input[type="range"] {
      width: 100px;
    }

    #controls {
      margin: 10px 0;
    }

    #imageInput, #imageURL {
      margin: 5px 0;
    }
  </style>
</head>
<body>

  <h1>üñåÔ∏è Draw on Image</h1>

  <div>
    <input type="file" id="imageInput" accept="image/*"><br>
    <input type="text" id="imageURL" placeholder="Paste image URL and press Enter" style="width: 60%;">
  </div>

  <canvas id="canvas" width="800" height="600"></canvas>

  <div id="controls">
    <label>Color: <input type="color" id="colorPicker" value="#ff0000"></label>
    <label>Size: <input type="range" id="brushSize" min="1" max="20" value="5"></label>
    <button onclick="clearCanvas()">Clear</button>
    <button onclick="downloadImage()">Download</button>
  </div>

  <script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let painting = false;
  let mode = 'draw'; // can be 'draw' or 'fill'

  // Mode toggle button
  const modeButton = document.createElement('button');
  modeButton.id = 'modeButton';
  modeButton.textContent = 'Mode: Draw';
  modeButton.onclick = toggleMode;
  document.getElementById('controls').appendChild(modeButton);

  function toggleMode() {
    if (mode === 'draw') {
      mode = 'fill';
      modeButton.textContent = 'Mode: Fill';
    } else {
      mode = 'draw';
      modeButton.textContent = 'Mode: Draw';
    }
  }

  // Event listeners for drawing
  canvas.addEventListener('mousedown', (e) => {
    if (mode === 'fill') {
      fillAtPoint(e);
    } else {
      startPosition(e);
    }
  });
  canvas.addEventListener('mouseup', endPosition);
  canvas.addEventListener('mouseout', endPosition);
  canvas.addEventListener('mousemove', draw);

  // Touch events
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (mode === 'fill') {
      fillAtPoint(e.touches[0]);
    } else {
      startPosition(e.touches[0]);
    }
  });
  canvas.addEventListener('touchend', endPosition);
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (mode !== 'fill') {
      draw(e.touches[0]);
    }
  });

  function startPosition(e) {
    painting = true;
    draw(e);
  }

  function endPosition() {
    painting = false;
    ctx.beginPath();
  }

  function draw(e) {
    if (!painting) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX !== undefined ? e.clientX - rect.left : e.pageX - rect.left;
    const y = e.clientY !== undefined ? e.clientY - rect.top : e.pageY - rect.top;

    ctx.lineWidth = document.getElementById('brushSize').value;
    ctx.lineCap = 'round';
    ctx.strokeStyle = document.getElementById('colorPicker').value;

    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
  }

  function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  function downloadImage() {
    const link = document.createElement('a');
    link.download = 'drawing.png';
    link.href = canvas.toDataURL();
    link.click();
  }

  // Load image from file
  document.getElementById('imageInput').addEventListener('change', function(e) {
    const reader = new FileReader();
    reader.onload = function(event) {
      const img = new Image();
      img.onload = function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
      }
      img.src = event.target.result;
    }
    reader.readAsDataURL(e.target.files[0]);
  });

  // Load image from URL
  document.getElementById('imageURL').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
      const url = e.target.value;
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
      }
      img.onerror = function() {
        alert("Failed to load image. Check the URL or CORS policy.");
      }
      img.src = url;
    }
  });

  // Flood fill implementation
  function fillAtPoint(e) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor(e.clientX - rect.left);
    const y = Math.floor(e.clientY - rect.top);
    const fillColor = document.getElementById('colorPicker').value;

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    const targetColor = getColorAtPixel(imageData, x, y);
    const fillColorRGB = hexToRgb(fillColor);

    if (!colorsMatch(targetColor, fillColorRGB)) {
      floodFill(imageData, x, y, targetColor, fillColorRGB);
      ctx.putImageData(imageData, 0, 0);
    }
  }

  // Helper to get pixel color
  function getColorAtPixel(imageData, x, y) {
    const index = (y * imageData.width + x) * 4;
    return {
      r: imageData.data[index],
      g: imageData.data[index + 1],
      b: imageData.data[index + 2],
      a: imageData.data[index + 3],
    };
  }

  // Converts hex color to RGB object
  function hexToRgb(hex) {
    const bigint = parseInt(hex.slice(1), 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return { r, g, b, a: 255 };
  }

  // Compare two colors with tolerance
  function colorsMatch(c1, c2, tolerance = 32) {
    return (
      Math.abs(c1.r - c2.r) <= tolerance &&
      Math.abs(c1.g - c2.g) <= tolerance &&
      Math.abs(c1.b - c2.b) <= tolerance
    );
  }

  // Flood fill algorithm
  function floodFill(imageData, x, y, targetColor, fillColor) {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;

    const stack = [];
    stack.push({ x, y });

    while (stack.length) {
      const { x: currentX, y: currentY } = stack.pop();
      const index = (currentY * width + currentX) * 4;

      const currentColor = {
        r: data[index],
        g: data[index + 1],
        b: data[index + 2],
        a: data[index + 3],
      };

      if (colorsMatch(currentColor, targetColor)) {
        // Set pixel to fillColor
        data[index] = fillColor.r;
        data[index + 1] = fillColor.g;
        data[index + 2] = fillColor.b;
        data[index + 3] = fillColor.a;

        // Push neighboring pixels within bounds
        if (currentX > 0) stack.push({ x: currentX - 1, y: currentY });
        if (currentX < width - 1) stack.push({ x: currentX + 1, y: currentY });
        if (currentY > 0) stack.push({ x: currentX, y: currentY - 1 });
        if (currentY < height - 1) stack.push({ x: currentX, y: currentY + 1 });
      }
    }
  }
</script>

</body>
</html>
